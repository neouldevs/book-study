# 1. 함수형 프로그래밍

함수형 프로그래밍의 예시를 들어보라고 하면 많이들 하는 이야기가 람다이다.  
이 패러다임의 핵심 기반이 람다 계산은 맞지만 이 패러다임이 추구하는 것은 람다가 아니다.  

함수형 프로그래밍에서 추구하는 것은

> 불변성

이다.  

상태 변화와 가변 데이터를 멀리하겠다는 뜻이다.  

함수형 프로그래밍의 예제 코드를 보자.  

```python
list(map(lambda x : x ** 2, range(25)))
```

# 2. 함수형 프로그래밍의 개념

책에는 없지만 추가해봄..  

함수형 프로그래밍의 대표적 개념을 정리해보자.  

- 1급 시민
- 순수 함수(pure function)
- 익명 함수(anonymous function)
- 고차 함수(high order function)
- 불변성
- 루프보단 재귀

## 2.1 1급 시민

다음을 만족하는 객체를 의미한다.  

1. 변수나 데이터 구조 안에 담을 수 있음
2. 파라미터로 전달 가능 (1번의 특성)
3. 반환값으로 사용 가능 (위와 동일)
4. 이름과 관계 없이 고유 식별 가능

## 2.2 순수 함수

사이드 이펙트가 없는 함수. 즉, 특정 입력에 대한 출력이 항상 일치함이 보장됨. 따라서 `thread-safe`하고 병렬적 계산이 가능하다.  

어떤 순수 함수 f가 있다고 가정하고 다음을 보자.  

```text
y = f(x) * f(x);
```

f는 순수 함수이기 때문에 다음과 같은 최적화가 가능해진다.  

```text
z = f(x)
y = z * z
```

계산(호출)은 두 번에서 한 번으로 줄어들지만 결과는 동일하다.  

이러한 특성 덕분에 함수를 조합해 합성 함수를 만들어 사용하는 것이 가능하다.  

## 2.3 익명 함수

전통적인 언어에선 함수는 반드시 이름이 있었다. 하지만 FO에서는 함수에 이름이 없어도 된다.  

```python
def something_great_sorting_fn(value_list, reverse):
    pass

something_great_sorting_fn(vl, lambda x, y: x >= y)
```

C++11의 경우에는

```cpp
[](int x) -> int { return x * x * x; }
```

## 2.4 고차 함수(High order function)

이미 앞서 소개했지만 함수를 다루는 함수이다. 이미 앞에서 다루었다.  
앞서 설명한 바와 같이 데이터와 함수 모두 값으로 취급하기 때문에 동등한 위치에서 다룰 수 있고, 따라서 함수를 다루는 함수도 가능하다.  

```python
map(lambda x : x ** 2, range(25))
```

이렇게 함수가 함수를 다루어 값을 생산하는 것이 가능하다.  

## 2.5 불변성

데이터 변경이 불가능하다. 따라서 데이터의 사본을 만드는 방법을 제공할 필요가 있다.  

## 2.6 루프보단 재귀

우리가 흔히 사용하는 루프의 형태를 보자.  

```cpp
for (int i = 0; i < 10; i++) {
    // do something
}
```

여기서 문제는? i의 값이 변하고 있다. 하지만 재귀를 사용하면 이러한 값 변화 없이 값을 생산할 수 있다.  

하지만 재귀의 문제점이 있는데:  
1. 스택 프레임이 무한하지 않다는 점 (overflow 위험성)
2. 함수 호출에는 코스트가 동반된다는 점

사실 이러한 이유 때문에 `tail recursion optimization`나 재귀 함수 최적화 같은 것들이 존재한다.  

# 3. 아키텍처의 관점에서는?

프로그램에서의 불변성은 충분히 납득했다. 하지만 아키텍처에서는 왜 중요할까?  
간단하다. 여러 시스템(프로세스, 스레드, 혹은 서비스)이 공유 자원에 대하여 race condition, deadlock, concurrent update 등을 발생 시킬 수 있기 때문이다.  

이 근본은 모두 `가변`에서 비롯된다. 가변 변수가 없다면 발생할 일이 아니다.  