# 1. 독립성

좋은 아키텍처는 다음을 지원해야 한다.  

- 시스템의 유스케이스
- 시스템의 운영
- 시스템의 개발
- 시스템의 배포

# 2. 유스케이스

> 아키텍처는 시스템의 행위에 그다지 큰 영향을 주지 않는다.  
> 행위와 관련하여 아키텍처가 열어 둘 수 있는 선택사항은 거의 없다.  
> 하지만 영향력이 전부는 아니다. 좋은 아키텍처가 행위를 지원하기 위해 할 수 있는 일 중에서 가장 중요한 사항은 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것이다.  

유스케이스라는 말이 확 와닿지 않을 수 있어서 예제를 투척해보자.  

우선 멤버를 표현하는 엔티티 `Member.java`가 있다.  

```java
@Getter
@Setter
@ToString
public class Member {
    private MemberId id;
    private String name;
    private Timestamp createdAt;
}

@Getter
@Setter
@ToString
public class MemberId {
    private String code;
}
```

그리고 이에 대한 용법(Use case)을 표현하는 유스케이스 `GetMemberByIdUseCase.java`를 보자.  

```java
public interface UseCase<IN, OUT> {
    OUT execute(IN request)
}

public class GetMemberByIdUseCase implements UserCase<MemberId, MemberResponseDto> {
    // 생략
    public MemberResponseDto
    execute(MemberId memberId) {
        return memberRepo.findByMemberId(memberId);
    }
}
```

극단적으로 간략하게 표현했지만 이것이 무엇을 하는지 확실히 표현하고 있다.  

> 장바구니 애플리케이션이 좋은 아키텍처를 갖춘다면, 이 애플리케이션은 장바구니 애플리케이션처럼 보일 것이다. 해당 시스템의 유스케이스는 시스템 구조 자체에서 한눈에 드러날 것이다.

# 3. 운영

이건 이 문장으로 요약 가능

> 아키텍처에서 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것이다.  

# 4. 개발

콘웨이의 법칙:

> 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.

내가 겪은(겪고 있는) 일이라 콘웨이의 이 quote 하나로 끝..  

# 5. 배포

> 좋은 아키텍처라면 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.  
> (중략)  
> 다시 말하지만, 이러한 아키텍처를 만들려면 시스템을 컴포넌트 단위로 적절하게 분할하고 격리시켜야 한다.  

각자가 맡은 기능에 맞는 컴포넌트로 분할하자.  

# 6. 선택사항 열어놓기

> 요컨대, 우리가 도달하려는 목표는 뚜렷하지 않을 뿐만 아니라 시시각각 변한다. 현실 세계에 온 것을 환영한다.  
> 그러나 이런 변화 속에서도 사라지지 않는 것이 있다. 몇몇 아키텍처 원칙은 구현하는 비용이 비교적 비싸지 않으며, 관심사들 사이에서 균형을 잡는데 도움이 된다. 심지어 균형을 맞추려는 목표점을 명확히 그릴 수 없는 경우에도 도움이 된다. 이들 원칙은 시스템을 제대로 격리된 컴포넌트 단위로 분할할 때 도움이 되며, 이를 통해 선택사항을 가능한 한 많이, 그리고 가능한 한 오랫동안 열어둘 수 있게 해준다.  

데이터를 DB에 넣을지 파일에 쓸지에 대한 결정과 한 발짝 떨어지려면 결국 저자가 계속해서 강조하는 `분할`을 잘해야한다. 이어서 나오는 내용에도 언급된다.  

# 7. 계층 결합 분리

> 아키텍트는 SRP와 OCP를 적용하여, 그 의도의 맥락에 따라서 다른 이유로 변경되는 것들은 분리하고, 동일한 이유로 변경되는 것들을 묶는다.  

응집도와 결합도에 대한 이야기이다.  

- 응집도: 변경의 이유가 동일한 것 끼리 모아둠. 모듈.  
- 결합도: 이 모듈의 수정이 다른 모듈까지 전파되어선 안됨.  

코드 레벨에서는 모듈, 객체 정도겠지만 아키텍처 레벨에서는 시스템도 포함될 수 있음.  

# 8. 유스케이스 결합 분리

> 서로 다른 이유로 변경되는 것에는 또 무엇이 있을까? 바로 유스케이스 그 자체가 있다!  
> 주문 입력 시스템에서 주문을 추가하는 유스케이스는 주문을 삭제하는 유스케이스와는 틀림없이 다른 속도로, 그리고 다른 이유로 변경된다. 유스케이스는 시스템을 분할하는 매우 자연스러운 방법이다.  
> 이와 동시에 유스케이스는 시스템의수평적인 계층을 가로지르도록 자른, 수직적으로 좁다란 조각이기도 하다. 각 유스케이스는 UI의 일부, 앱 특화 업무 규칙의 일부, 독립적 업무 규칙의 일부, DB 기능의 일부를 사용한다.  

