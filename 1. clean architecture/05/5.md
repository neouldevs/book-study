# 1. 객체지향 프로그래밍

흔한 간단 설명:  

1. 데이터와 함수의 조합
2. 실제 세계를 모델링 하는 방법
3. 캡슐화, 상속, 다형성

반박:

1. o.f()는 f(o)랑 다르다는 뜻인가?  
2. 실제로 실제 세계를 모델링 하지 않음. 오히려 불필요 부분을 제거함.
3. 진부한 설명이긴 한데 필요한 기능들임

# 2. 캡슐화, 상속, 다형성

객체 지향(OO) 패러다임을 지원하는 언어의 대표적인 세 가지 기능에 대해 정리한다.  

## 2.1 캡슐화

캡슐화의 목적은 응집성이다. 즉, 명확한 선을 긋기 위함이다.  
A라는 일을 수행하기 위한 모듈이 사용하는 데이터와 내부 처리함수는 외부로 노출 될 필요가 없다. 오히려 노출로 인해 발생하는 사이드 이펙트는 답이 없다.  

노출 되는 것은 그저 일부 함수일 뿐이다. 이 노출되는 함수가 인터페이스가 될 수 있는 것이고.  

캡슐화는 비단 객체지향 언어만 갖는 것은 아니다. (어떤 패러다임을 실현하기 위한 메커니즘을 지원하는 것이지, 다른 언어에서 불가능하다는 의미가 아님)  

다음 C코드를 보자.  

`point.h`
```c
struct Point;
struct Point* make_point(double x, double y);
```

`point.c`
```c
struct Point {
    double x, y;
};

struct Point* make_point(double x, double y) {
    struct Point* p = malloc(sizeof(struct Point));
    p->x = x;
    p->y = y;
    return p;
}
```

포인트 헤더를 사용하는 곳에서 구조체 멤버에 코드 레벨(여러 C의 편법적 테크닉 제외)에서 접근할 방법을 제공하지 않는다.  

C는 객체지향 언어가 아님에도 캡슐화가 실현되었다.  

하지만 C++에 와서는 이 것이 클래스 선언에 의해 깨져버렸다.  
Java, C#은 헤더와 구현체를 분리하는 방식이 아니기 때문에 `클래스 선언`과 `정의`를 구분할 수 없게 되었다.  

(물론 OO 언어들은 이를 접근 지정자로 어느 정도 보완함. 바꿔 말하면 private, public, protected과 같은 키워드들이 캡슐화를 대표한다는 것은 아니라는 뜻)

## 2.2 상속

상속은 데이터와 함수를 어떤 스코프로 묶어 재정의하는 것에 불과하다.  

## 2.3 다형성

다형성 또한 OO의 전유물이 아니다. 이 전에도 다형성은 실현되어 왔다.  

대표적인 예가 리눅스의 VFS. C의 STDIN, STDOUT  

`VFS`는 어떤 파일 시스템에 쓰기를 하는지는 관심이 없다. 왜냐면 다형적이기 때문이다. (즉, 이게 인터페이스)  
또, STDIN, STDOUT을 보자. 입출력 장치에 관심이 있을까? 없다. 이 역시 다형적이기 때문이다. (인터페이스!)  

자바의 경우에는 인터페이스가 있고, 이에 대한 구현체가 개별로 있을 것이다. C에서는 인터페이스에 해당하는 IO 표준 함수를 정의하고 입출력 장치 드라이버들이 이를 구현해둘 것을 스펙으로 요구하기 때문에 각 장치들이 이를 구현하고, 구현한 함수들의 주소 값을 받아서 쓸 것이다.  

원시적인 OO 언어인 C++의 경우에는 가상 함수의 주소를 지닌 vtable로 이를 구현.  

### 2.3.1 다형성의 힘

코드 수정 없이 모듈 변경

이거 말고 더 있을 수 있나?  

### 2.3.2 의존성 역전

이것도 위의 특성을 이용한 것임.  

